## [참고](https://systemdesigner.tistory.com/18)  

# 멀티태스킹  

* 멀티태스킹은 하나의 호스트에서 두 개 이상의 `프로세스`를 **동시에** 실행시키는 것.  
* 멀티태스킹은 두 가지로 분류된다.  

1. **협동형 멀티태스킹(Cooperative)** : 실행 중인 `프로세스`가 **자발적**으로 `yield`해야 다음 프로세스가 실행됨.  
2. **선점형 멀티태스킹(Preemptive)** : 실행 중인 프로세스가 점유 중인 `CPU`를 **스케줄러**가 강제로 뺏은 후 다른 프로세스에게 할당시켜줄 수 있다.  

* 프로세스가 `선점`되기 전까지, 그 프로세스가 할당받은 시간을 **타임 슬라이스**라고 한다.  

[-] 비선점형 스케쥴링의 단점은 하나의 프로세스가 CPU를 독점할 수 있기에, 전체 시스템의 **Response time**이 저하될 수 있다.  
[+] 비선점형 스케쥴리의 장점은 과도한 **컨텍스트 스위칭**이 없기에, **Batch Job**에 적합하며 전체 **Throughput**이 증가한다.  



# 리눅스의 프로세스 스케줄러  
* 커널 시리즈 2.5부터 정비에 들어갔다.  

* **O(1) 스케줄러** : Batch Job 시스템에 적합하지만, 빠른 Response time이 요구되는 User Interactive한 시스템에서는 `평균 이하의 성능`.  

[ + ] User Interactive한 시스템에 더 적합하도록 개선한 스케쥴러가  
[ + ] 2.6.23 커널 시리즈부터 도입  
* **CFS 스케줄러** : Completely Fair Schedueler 완전 공정 스케줄러  

# 정책  

* `Policy` : `정책`이란 무엇을 언제 어떻게 실행시킬지를 정하는 동작.  


# 입출력중심 프로세스와 프로세서중심 프로세스  

* **IO-Bound** 프로세스 : io bound 프로세스는 **입출력 요청과 그 완료를 기다리는데 대부분의 시간을 소비**한다.  

* **CPU-Bound** 프로세스 : 반면, cpu bound 프로세스는 대부분의 시간을 코드를 실행하는데 사용한다.  

# 프로세스 우선순위  
* `스케줄링 알고리즘`의 기본적인 방식은 **우선순위**을 기반으로 스케줄링하는 것이다.  

### 1. 일반적인 방식  
* 프로세스의 경중을 바탕으로 우선순위를 차등적으로 매긴 후 우선순위가 높은 프로세스를 먼저 실행하고, 같은 프로세스라면 Round Robin으로 실행한다.  


### 2. 리눅스 커널의 방식  
* 두 가지의 별개의 **우선순위 단위**를 가지고 있다.  

* **1. 나이스 값** : -20 에서 +19 사이의 값을 가지며, 기본값은 0이다.  
[+] 나이스값이 클수록 우선순위가 낮다.  
[+] 나이스값이 크다는 것은 그만큼 나이스(친절)하다는 것이고, 관대하다는 뜻이 우선순위가 낮아서 양보하는 것.  

* `나이스 값`은 유닉스 시스템에서의 우선순위 표기 방식이다.  
**리눅스**에서는 이 나이스 값을 바탕으로 **타임 슬라이스 비율**을 조절한다.  

* **2. 실시간 우선순위** : 0 ~ 99까지의 값을 가진다.  
[+] 나이스값과 반대로, 이 값은 클수록 우선순위가 높다.  
* 



























