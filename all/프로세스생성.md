

# 프로세스 생성  

* 새로운 프로세스는 어떻게 생성되는가?  

*  **fork(2)** 와 **exec() 함수군** 두 가지를 조합하여 새로운 프로세스를 생성한다.  

## 1. fork(2)  
### [fork(2)와 exec(3)](https://blackinkgj.github.io/fork_and_exec/)  

* fork(2) 시스템콜은 이를 호출한 `프로세스`를 복사하여 메모리에 새로운 프로세스를 생성한다.  
* 이 때 복사되는 것은 **텍스트**, **스택**, **힙**, **PCB** 등이 있다.  
* 이후 부모와 자식 프로세스 모두 fork(2) 함수의 반환 이후부터 시작된다.  


## 2. exec(3)  
* exec(3) 함수군은 새로운 `실행 파일`을 인자로 받아, `기존의 프로세스 이미지`를 덮어버린다.  

```
#include<unistd.h>
int execl(const char *path, const char *arg, ...);
```
* **실행파일**의 위치를 path에 넘긴다.  
* 이후 **인자**를 넘기되, 더 이상 넘길 인자가 없으면 NULL을 통해 끝을 알린다.  

```
execl("/bin/ls", "/bin/ls", "-al", "/tmp", NULL);
```
* 위의 경우 `ls` 프로그램을 실행시킬 때 사용하는 `execl`의 예제이다.  


## 3. COW(Copy-on-Write)  
* 실제로 쓰기 발생 시에 비로소 **복사**를 하는 것.  
* 복사된 것이 이후 바뀌지 않거나 혹은 아예 다른 것으로 바뀐다면 굳이 복사할 필요가 없을 것이다.  

* `fork(2)`함수는 이러한 COW를 적용했다.  

원래의 fork(2)함수는 새로운 프로세스를 생성할 때, 자신의 이미지를 메모리에 모두 복사한다.  
하지만 곧 바로 exec(3)가 호출된다면 **그 복사작업**은 헛수고가 된다.  

* 그렇기에 COW가 적용된 fork(2)는 곧 바로 `메모리 복사작업`을 수행하지 않고  
단지 자식 프로세스의 **페이지 테이블**과 **PCB**만을 우선 생성한다.   

fork() -> clone() -> do_fork()  


## 4. vfork(2)  

* 부모의 **페이지 테이블**을 복사하지도 않는다는 점, 자식이 exec(3)를 호출하기 전까지 부모는 suspend 된다는 점을 제외하고 fork(2)와 동일.  






























