

# 프로세스  

* 실행 중인 프로그램(Disk에 저장된 Executable Object File)  
* 뿐만 아니라 `열린 파일`, `대기 중인 시그널`, `프로세서 상태`, `메모리 주소 공간` 등 모든 자원을 포괄하는 개념  

* 쓰레드는 프로세스 내부에 존재하는 객체로, 독자적인 `프로그램 카운터(PC)`, `스택 영역`, `레티스터 셋`을 가진다.   
리눅스에서는 **프로세스와 쓰레드를 구분하지 않는다**.  

1. **프로세스**란 **실행 중인 프로그램**과 **그것과 관련된 자원**을 의미한다.  
2. 프로세스는 두 가지의 가상 자원을 할당받는다.  
**2.1. 가상 프로세서** : 100개의 프로세스가 하나의 core 위에서 동작하더라도 자신이 하나의 CPU를 독점하는 것과 같은 가상환경.  
**2.2. 가상 메모리** : 프로세스가 혼자 시스템 전체의 메모리를 차지하여 동작하는 것과 같은 가상환경.  

#### fork(2)  
* 리눅스에서는 **fork() 시스템 콜**을 통하여 새로운 프로세스가 생성된다.  
* fork(2)는 기존 프로세스를 **복사**해서 새로운 프로세스를 생성하며, 이 때 부모와 자식 관계가 생긴다.  

#### exec(3)  
* 대개의 경우 fork직후 exec() 함수군(family)를 호출하여 **다른 새 프로그램**을 호출한다.  



# 프로세스 서술자와 테스크 구조체  

* 커널은 자신이 관리하는 프로세스들을 **테스크 리스트**(task list)로 관리한다.  
* 이는 **환형 양방향 연결리스트**이다.  

## 1.task_struct 구조체  
* <linux/sched.h>  
* 32bit 시스템에서 1.7KB 정도의 크기를 가지지만, task_struct 구조체에서는 프로세스 관리에 필요한 정보를 모두 담고 있다.  

* task_struct 구조체는 **슬랩 할당자**를 사용하여 할당된다.  


## 2. 현재 실행 중인 프로세스의 정보에 접근하는 방법  
* 커널 내부에서 테스크에 접근할 때는 보통 task_struct 구조체의 포인터를 통해 접근한다.  

* 현재 실행 중인 테스크 정보에 빠르게 접근하기 위한 두 가지 방법  

1. `thread_info`구조체의 위치는 쉽게 구해져서, `thread_info 구조체`에 저장된 current task의 정보를 가져오는 방식  
2. 레지스터에 현재의 `task_struct`의 포인터를 저장해서 접근하는 방식  


## 3. 프로세스 상태  
#### [참고](https://sonseungha.tistory.com/248?category=451586)  

* `task_struct`의 **volatile long state**에 의해 표현  

#### 3.1. 각 상태값  

1. TASK_RUNNING : 프로세스가 실행 중이거나, 실행가능한 상태  
2. TASK_INTERRUPTIBLE : 특정 조건을 기다리며 쉬는 상태, `시그널`에 의해 활성화 가능.  
3. TASK_UNINTERRUPTBILE : `시그널`에 의해 활성화 불가  
4. __TASK_TRACED__ : 다른 프로세스에 의해 추척당하는 상태  
5. __TASK_STOPPED__ : 실행이 정지된 상태.  























